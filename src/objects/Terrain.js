/* * This file contains the code necessary for terrain manipulation
 */

B.Terrain = B.Class.extend({
	options: {},
	callbackQueue: [],
	objCount: 0,
	initialize: function (bounds, options) {
		// terrainMesh - A mesh for the terrain, generated by the worker
		options = B.setOptions(this, options);

		this._bounds = bounds;
		this._origin = bounds.getSouthWest();

		return this;
	},
	buildMesh: function (geoParts) {
		// Rebuild the geometry from it's parts


		
		this._geometry = new THREE.PlaneGeometry(geoParts.width, geoParts.height,
			geoParts.numVertsX - 1, geoParts.numVertsY - 1);

		console.log('vertices');
		var verts = geoParts.vertices;
		for (var i = 0, l = verts.length; i < l; i += 3) {
			this._geometry.vertices[i / 3] = new THREE.Vector3(verts[i],
				verts[i + 1], verts[i + 2]);
		}
		console.log('faces');
		var faces = geoParts.faces;
		for (var j = 0, k = faces.length; j < k; j += 3) {
			this._geometry.faces[j / 3] = new THREE.Face3(faces[j],
				faces[j + 1], faces[j + 2]);
		}

		this._geometry.computeFaceNormals();
		this._geometry.computeVertexNormals();
		this._geometry.verticesNeedUpdate = true;

		this._numVertsX = geoParts.numVertsX;
		this._numVertsY = geoParts.numVertsY;
		this._gridSpaceX = geoParts.gridSpaceX;
		this._gridSpaceY = geoParts.gridSpaceY;



		this._createMesh();
		

		return this;
	},
	addObjectCallback: function (object, callback) {
		if (typeof this._mesh === 'undefined') {
			this.callbackQueue.push({
				object: object,
				callback: callback
			});
		} else {
			callback(object);
		}
	},
	runQueuedCallbacks: function () {
		// Wait 20 ms to prevent race conditions
		setTimeout(function () {
			if (this.callbackQueue.length === 0) { return; }
			var i = 0;
			var func = function () {

				var cb = this.callbackQueue[i];
				cb.callback(cb.object);

				// Space out the callbacks by 1 ms, to give time to update dom.
				if (i < this.callbackQueue.length - 1) {
					i++;
					setTimeout(func, 1);
				}
			}.bind(this);
			func();
		}.bind(this), 20);
	},
	updateObjPosition: function (object) {
		object.position.z = this.heightAt(object.position.x, object.position.y);
		//this.objCount++;
		//console.log(this.objCount);
	},
	heightAtLatLon: function (lat, lon, xym) {
		// Return the elevation of the terrain at the given lat/lon
		
		if (!this._bounds.contains([lat, lon])) {
			//throw new Error('Coordinates outside of bounds');
			console.error('Coordinates outside of bounds');
			return 0;
		}

		if (!xym) {
			xym = this._latlon2meters(lat, lon);
		}
		this.heightAt(xym.x, xym.y);
	},
	heightAt: function (x, y) {
		// Get the coords of the tile the point falls into (relative to top left)
		var ix = Math.floor((x) / this._gridSpaceX);
		var iy = (this._numVertsY - 2) - Math.floor((y) / this._gridSpaceY);

		// Get the positions of the 4 data points
		var nwDP = (this._numVertsX * iy) + ix,
			neDP = nwDP + 1,
			swDP = nwDP + this._numVertsX,
			seDP = swDP + 1;

		// Get the vectors of the 4 surrounding points
		var nw = this._copyVertexByValue(this._geometry.vertices[nwDP]),
			ne = this._copyVertexByValue(this._geometry.vertices[neDP]),
			se = this._copyVertexByValue(this._geometry.vertices[seDP]),
			sw = this._copyVertexByValue(this._geometry.vertices[swDP]);

		nw.x += this._mesh.position.x;
		ne.x += this._mesh.position.x;
		se.x += this._mesh.position.x;
		sw.x += this._mesh.position.x;

		nw.y += this._mesh.position.y;
		ne.y += this._mesh.position.y;
		se.y += this._mesh.position.y;
		sw.y += this._mesh.position.y;

		var px = ((x) / this._gridSpaceX) - Math.floor((x) / this._gridSpaceX);
		var py = ((y) / this._gridSpaceY) - Math.floor((y) / this._gridSpaceY);

		var lerp = this._lerp;
		// Calculate the elevation based on a linear interpolation between the surrounding points
		return lerp(lerp(nw.z, se.z, (1 + px - py) / 2), px > (1 - py) ? ne.z : se.z, Math.abs(1 - px - py));
	},
	_copyVertexByValue: function (vertex) {
		return new THREE.Vector3(
			vertex.x,
			vertex.y,
			vertex.z);
	},
	_lerp: function (v1, v2, f) {
		return v1 + (v2 - v1) * f;
	},
	worldVector: function (lat, lon) {
		// Return a Vector3 with world coords for given lat, lon
		var xym = this._latlon2meters(lat, lon);

		var ele = this.heightAt(lat, lon, xym);

		return new THREE.Vector3(xym.x, xym.y, ele);
	},
	addTo: function (model) {
		model.addTerrain(this);
		return this;
	},
	_createMesh: function () {
		var texture = THREE.ImageUtils.loadTexture(B.Util.getTexturePath() + '/seamless-grass.jpg');
		var widthOfTexture = 50; // meters
		var heightOfTexture = 50; // meters
		texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		texture.repeat.set(Math.round(this._dataDepthInMeters / heightOfTexture),
				Math.round(this._dataWidthInMeters / widthOfTexture));
		this._mesh = new THREE.Mesh(this._geometry, new THREE.MeshPhongMaterial({
			map: texture
			// For debugging
			/*wireframe: true,
			color: 0x0000ff*/
		}));

		// Enable shadows for the ground
		this._mesh.castShadow = true;
		this._mesh.receiveShadow = true;

		// Move the mesh so that the origin is in the southwest corner
		this._mesh.translateX(this._geometry.width / 2);
		this._mesh.translateY(this._geometry.height / 2);
	},
	_latlon2meters: function (lat, lon) {
		// This function takes a lat/lon pair, and converts it to meters,
		// relative to the origin of the terrain, and returns x,y, and 
		// straightLine distances

		// normalize the input into a B.LatLng object
		var latlng = B.latLng(lat, lon);

		return {
			x: this._origin.distanceTo([this._origin.lat, latlng.lng]),
			y: this._origin.distanceTo([latlng.lat, this._origin.lng]),
			straightLine: latlng.distanceTo(this._origin)
		};
	}

});
